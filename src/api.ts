import type {
	InquiryGameServer,
	PostpaidInqueryData,
	Pricelist
} from '@iak-id/iak-api-server-js'
import type {
	Operator as ProductOperator,
	Product,
	ProductCategory
} from '@prisma/client'
import type { Record } from '@prisma/client/runtime/library'
import supabase from 'client'
import {
	CategoryListEndpoint,
	FirstPage,
	GetGameServerEndpoint,
	HttpInternalServerError,
	HttpNotFound,
	HttpOK,
	OperatorListEndpoint,
	PaymentListEndpoint,
	PlaceOrderEndpoint,
	ProductInQueryEndpoint,
	ProductListEndpoint
} from 'constant'
import fetch from 'cross-fetch'
import LoadMoreError from 'errors/LoadMoreError'
import NotFoundError from 'errors/NotFoundError'
// eslint-disable-next-line unicorn/prefer-node-protocol
import { promises as fs } from 'fs'
// eslint-disable-next-line unicorn/prefer-node-protocol
import path from 'path'
import type {
	InqueryInOrder,
	InqueryWithOrder,
	IpayMuDatum,
	IpayMuDirectPayData,
	ToupRequest
} from 'types'

export interface IMetaImage {
	filename: string
	hash: string
	sources: string[]
}

export interface IBlogListItem {
	title: string
	description: string
	publishedAt: Date
	thumbnail: string
	label: string[]
	commentId: number
	readTime: number
	link: string
}

export interface IBaseData {
	publishedAt?: string
	body: string
}

export interface IBlogArticle {
	attributes: Omit<IBlogListItem, 'link'> & {
		commentId: number
	}
	body: string
}

export interface IBlogArticleDto {
	attributes: Omit<IBlogListItem, 'publishedAt'> & {
		publishedAt: string
	}
	body: string
}

export interface IProjectList {
	name: string
	description: string
	tags: string[]
	pinned: boolean
	thumbnail: string
	demoUrl: string
	createdAt: Date
	sourceUrl: string
	link: string
}

export interface IProject {
	attributes: Omit<IProjectList, 'link'>
	body: string
}
// generated by quicktype
export interface IConfig {
	name: string
	birthdate: Date
	avatar: string
	background: string
	jargon: string
	github: string
	repository: string
	quote: string
	email: string
	phone: string
	fullName: string
	contact: Contact
	skills: IConfigSkill[]
	about: About
}

export interface About {
	intro: string
	jobExperiences: JobExperience[]
	educations: Education[]
	languages: Language[]
	hobby: string[]
	skills: AboutSkill[]
	tools: Tool[]
}

export interface Education {
	type: string
	name: string
	startAt: Date
	graduationAt: Date
	location: string
	description: string
}

export interface JobExperience {
	company: string
	location: string
	position: string
	startAt: Date
	endAt: Date
	description: string
}

export interface Language {
	name: string
	level: string
}

export interface AboutSkill {
	icon: string
	group?: string
	name: string
	level: number
}

export interface Tool {
	icon: string
	name: string
	hasColor?: boolean
}

export interface Contact {
	address: string
	phone: string
	email: string
	github: string
	instagram: string
	linkedin: string
}

export interface IConfigSkill {
	name: string
	techs: string[]
}

// end generated type
export enum Subject {
	JobOffer = 'JobOffer',
	Project = 'Project',
	Freelance = 'Freelance'
}

export interface ScheduleData {
	email: string
	phone: string
	fullname: string
	company?: string
	subject: Subject
	message: string
	meet_date: string
	duration: number
}
export interface Schedule extends ScheduleData {
	id: string
	created_at: string
}

export interface ProductList extends Pricelist {
	kind: 'postpaid' | 'prepaid'
}

export interface IPriceListApiResult {
	indexs: Record<string, Record<string, string[]>>
	pricelist: ProductList[]
}

export async function getConfig(language: string): Promise<IConfig> {
	const result = await fetch(`/_data/${language}/config.json`)
	if (result.status === HttpNotFound) {
		throw new NotFoundError('page not found')
	}
	const config = (await result.json()) as IConfig

	return config
}

export async function getGameServer(
	gameCode: number
): Promise<InquiryGameServer[]> {
	if (gameCode === 0) {
		return []
	}
	const result = await fetch(`${GetGameServerEndpoint}?gameCode=${gameCode}`)

	if (result.status !== HttpOK) {
		throw new Error(await result.text())
	}

	const servers = (await result.json()) as InquiryGameServer[]

	return servers
}

export async function getPaymentList(): Promise<IpayMuDatum[]> {
	const result = await fetch(PaymentListEndpoint)

	if (result.status !== HttpOK) {
		throw new Error(await result.text())
	}

	const paymentList: IpayMuDatum[] = (await result.json()) as IpayMuDatum[]

	return paymentList
}

export async function getPinnedProjects(
	language: string
): Promise<IProjectList[]> {
	const result = await fetch(`/_data/${language}/projects/index-pinned.json`)
	if (result.status === HttpNotFound) {
		throw new NotFoundError("requested file doesn't exist")
	}
	const projectList: IProjectList[] = (await result.json()) as IProjectList[]
	return projectList.map(data => ({
		...data,
		createdAt: new Date(String(data.createdAt))
	}))
}

export async function getProductList(operatroCode: string): Promise<Product[]> {
	const result = await fetch(`${ProductListEndpoint}?code=${operatroCode}`)

	if (result.status !== HttpOK) {
		throw new Error('failed to load data')
	}

	const products = (await result.json()) as Product[]
	return products
}

export async function getCategoryList(): Promise<ProductCategory[]> {
	const result = await fetch(CategoryListEndpoint)

	if (result.status !== HttpOK) {
		throw new Error('failed to load data')
	}

	const category = (await result.json()) as ProductCategory[]

	return category
}

export async function getOperatorList(
	categoryCode: string
): Promise<ProductOperator[]> {
	const result = await fetch(`${OperatorListEndpoint}?code=${categoryCode}`)

	if (result.status !== HttpOK) {
		throw new Error('failed to load data')
	}

	const operators = (await result.json()) as ProductOperator[]

	return operators
}

export async function inqueryOrder(
	data: InqueryInOrder
): Promise<PostpaidInqueryData> {
	const result = await fetch(ProductInQueryEndpoint, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json'
		},
		body: JSON.stringify(data)
	})

	if (result.status === HttpInternalServerError) {
		throw new Error('failed to send data')
	}

	const order = (await result.json()) as InqueryWithOrder

	return order
}

export async function getProjectListPaged(
	page: number,
	language: string
): Promise<IProjectList[]> {
	const result = await fetch(
		`/_data/${language}/projects/index-page-${page}.json`
	)

	if (result.status === HttpNotFound && page > FirstPage) {
		throw new LoadMoreError('Project not found')
	}

	const projectList: IProjectList[] = (await result.json()) as IProjectList[]
	return projectList.map(data => ({
		...data,
		createdAt: new Date(String(data.createdAt))
	}))
}

export async function getArticleList(
	language: string
): Promise<IBlogListItem[]> {
	const articleList: IBlogListItem[] = []
	const jsonDirectory = path.join(
		process.cwd(),
		`/public/_data/${language}/articles`
	)
	let page = FirstPage

	// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	while (true) {
		try {
			const indexFilePath = `${jsonDirectory}/index-page-${page}.json`
			console.log('index', indexFilePath)

			// eslint-disable-next-line no-await-in-loop
			const result = await fs.readFile(indexFilePath)

			const dataResult = JSON.parse(result.toString('utf8')) as IBlogListItem[]

			for (const item of dataResult) {
				articleList.push({
					...item,
					publishedAt: new Date(String(item.publishedAt))
				})
			}

			// articleList.push(...dataResult)
			// eslint-disable-next-line @typescript-eslint/no-magic-numbers
			page += 1
		} catch {
			break
		}
	}

	return articleList
}

export async function getNodeArticleDetail(
	slug: string,
	language: string
): Promise<IBlogArticleDto> {
	const jsonDirectory = path.join(
		process.cwd(),
		`/public/_data/${language}/articles`
	)
	const result = await fs.readFile(`${jsonDirectory}/${slug}.json`)
	const article = JSON.parse(result.toString('utf8')) as IBlogArticleDto

	return article
}

/**
 * Retrieves a list of projects based on the specified language.
 *
 * @param {string} language - The language to filter the projects by.
 * @return {Promise<IProjectList[]>} - A promise that resolves to an array of project lists.
 */
export async function getProjectList(
	language: string
): Promise<IProjectList[]> {
	const projectList: IProjectList[] = []
	const jsonDirectory = path.join(
		process.cwd(),
		`/public/_data/${language}/projects`
	)
	let page = FirstPage

	// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	while (true) {
		try {
			const indexFilePath = `${jsonDirectory}/index-page-${page}.json`
			console.log('index', indexFilePath)

			// eslint-disable-next-line no-await-in-loop
			const result = await fs.readFile(indexFilePath)

			const dataResult = JSON.parse(result.toString('utf8')) as IProjectList[]

			projectList.push(...dataResult)
			// eslint-disable-next-line @typescript-eslint/no-magic-numbers
			page += 1
		} catch {
			break
		}
	}

	return projectList
}

/**
 * Retrieves the project details for a specific slug and language.
 *
 * @param {string} slug - The slug of the project.
 * @param {string} language - The language of the project.
 * @return {Promise<IProject>} A promise that resolves to the project details.
 */
export async function getNodeProjectDetail(
	slug: string,
	language: string
): Promise<IProject> {
	const jsonDirectory = path.join(
		process.cwd(),
		`/public/_data/${language}/projects`
	)
	const result = await fs.readFile(`${jsonDirectory}/${slug}.json`)
	const project = JSON.parse(result.toString('utf8')) as IProject

	return {
		attributes: project.attributes,
		body: project.body
	}
}

export async function getBlogListPaged(
	page: number,
	language: string
): Promise<IBlogListItem[]> {
	const result = await fetch(
		`/_data/${language}/articles/index-page-${page}.json`
	)

	if (result.status === HttpNotFound && page > FirstPage) {
		throw new LoadMoreError('Articles not found')
	}

	const blogList: IBlogListItem[] = (await result.json()) as IBlogListItem[]
	// eslint-disable-next-line @typescript-eslint/no-unsafe-return
	return blogList.map(data => ({
		...data,
		// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
		publishedAt: new Date(String(data.publishedAt))
	}))
}

export async function getBlogArticle(
	slug: string,
	language: string
): Promise<IBlogArticle> {
	const result = await fetch(`/_data/${language}/articles/${slug}.json`)

	if (result.status === HttpNotFound) {
		throw new Error('Article not found')
	}

	const article: IBlogArticle = (await result.json()) as IBlogArticle
	return {
		attributes: {
			...article.attributes,
			publishedAt: new Date(String(article.attributes.publishedAt))
		},
		body: article.body
	}
}

export async function getProjectDetail(
	slug: string,
	language: string
): Promise<IProject> {
	const result = await fetch(`/_data/${language}/projects/${slug}.json`)

	if (result.status === HttpNotFound) {
		throw new Error('Article not found')
	}

	const project: IProject = (await result.json()) as IProject
	return {
		attributes: project.attributes,
		body: project.body
	}
}

export async function addSchedule(schedule: ScheduleData): Promise<Schedule> {
	const { data, error } = await supabase.from<Schedule>('schedules').insert([
		{
			company: schedule.company,
			email: schedule.email,
			fullname: schedule.fullname,
			message: schedule.message,
			meet_date: schedule.meet_date,
			phone: schedule.phone,
			duration: schedule.duration,
			subject: schedule.subject
		}
	])
	if (error) {
		console.log(error)
		throw new Error(error.message)
	}

	return data[0]
}

export async function placeOrder(
	topup: ToupRequest
): Promise<IpayMuDirectPayData> {
	const result = await fetch(PlaceOrderEndpoint, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json'
		},
		body: JSON.stringify(topup)
	})

	if (result.status !== HttpOK) {
		throw new Error('failed to send data')
	}

	const order = (await result.json()) as IpayMuDirectPayData

	return order
}
